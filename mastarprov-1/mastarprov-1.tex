\documentclass[11pt]{article}
\usepackage[a4paper]{geometry}
\usepackage[swedish]{babel}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsmath}

\title{Mästarprov 1}
\author{André Josefsson}

\begin{document}

\maketitle

\section{Hantverkare}
Algoriritmen använder använder sig av en vektor $times$ innehållandes tiderna $t_1,...,t_n$ för de olika hantverkarna. Den väljer sedan helt enkelt det minsta elementet vid varje iteration i while loopen. Kostnaden ökar med elementets värde gånger antalet hantverkare som är kvar i vektorn (eftersom det precis motsvarar antalet hantverkare som ska ha betalt för tiden). Slutligen lyfts elementet ut ur vektorn då den hantverkaren kan gå hem. Loopen upprepas tills dess att alla hantverkare har gått hem. Då innehåller $cost$ precis kostnaden för renoveringsarbetet.

\begin{algorithm}
\begin{algorithmic}[0]
\State Hantverkarkostnad(times[1..n]) =
\State \textbf{Sortera times med mergesort}
\State $cost \gets$ 0
\While{$times$ is not empty}
\State \textbf{invariant}
\State  $t \gets$ lowest value from $times$
\State $cost = cost + t * |times| * 100$
\State \textbf{remove} $t$ from $times$
\EndWhile
\State  \textbf{return} $cost$
\end{algorithmic}
\end{algorithm}

Loop invarianten är: $cost$ motsvarar den minimala kostnaden för att utföra de borttagna arbetena med n stycken hantverkare från början.\\\\

Algoritmens korrekthet bevisas med följande resonemang:\\
Med 0 eller 1 st hantverkare är lösningen trivial. Antag nu att $k$ är den minsta kostnaden för att utföra $m \geq 2$ st hantverkararbeten. Lösningen innehåller $m$ st arbeten utförda i ordningen $a_1,...,a_m$. Om $k$ skulle åstadkommits genom att välja hantverkarna i en annan ordning än icke-avtagande borde det finnas två hantverkararbeten $a_i$ och $a_j$ sådana att $t_i > t_j$ och $1 \leq i < j \leq m$. Kostnaden för de två arbetena är $t_i * (m+1-i)$ och $t_j * (m+1-j)$. Genom att byta plats på $a_i$ och $a_j$ förblir kostnaden för alla andra arbeten oförändrade, medan de två arbetena nu får kostnaden $t_i * (m+1-j)$ och $t_j * (m+1-i)$. Men eftersom $t_i > t_j$ och $(m+1-i) > (m+1-j)$ måste vi nu fått en strikt mindre kostnad (Kort bevis för varför det är så finns i avsnitt 3). $k$ måste alltså åstadklommits genom att välja hantverkarna i en icke-avtagande ordning. Då detta är precis vad den beskrivna algoritmen gör är korrekthet i ordningen alltså visad.\\
När ordningen är korrekt behöver algoritmen endast addera rätt mängd till kostnaden varje loopvarv för att vara korrekt. Rätt kostnad för varje arbete är tiden för arbetet multiplicerat med antalet hantverkare som ska få betalt under tiden, alltså alla som väntar plus den som arbetar. Loop invarianten visar att detta håller.\\

Tidskomplexiteten är $\mathcal{O}(nlog(n))$

\section{Höravstånd}

\section{Tillägg}
För två par av positiva tal $a$ och $b$, samt $x$ och $y$, gäller att $ax+by > ay+bx$ om $a>b$ samt $x>y$.\\
\textbf{Bevis:}\\
Låt $a=b+\epsilon_1$, $\epsilon_1 > 0$ och $x=y+\epsilon_2$, $\epsilon_2 > 0$.\\
Olikheten kan nu skrivas som: $(b+\epsilon_1)(y+\epsilon_2)+by > (b+\epsilon_1)y+b(y+\epsilon_2)$ $\Longleftrightarrow$ $by+b\epsilon_2+y\epsilon_1+\epsilon_1\epsilon_2+by > by+y\epsilon_1+by+b\epsilon_2$ $\Longleftrightarrow$ $\epsilon_1\epsilon_2 > 0$ som uppenbart är sant.

\end{document}